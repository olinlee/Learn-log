# questions

1. 页面中输入一个url到页面渲染经历哪些过程

     ```
     dns=>三次握手=>服务器响应=>接收页面=>（dom tree，cssom tree）render
     ```

2. DNS解析是基于怎样的顺序的

     ```
     (先浏览器==>本机)=>(自定义线路 > 运营商线路 > 地域线路 > 全网默认)
     
     dns客户机查询==》本地到服务器查询 =》服务器到服务器查询
     ```

3. 你平时开发的时候需要改host吗

     ```
     需要，为了方便，在服务器未部署的情况下与后端联调接口时
     ```

4. 你觉得http和https之间什么区别

   ```
   1. http是80端口，https是443端口
   2. https协议需要申请证书，一般免费证书比较少，所以需要一定的费用。
   3. http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议
   ```

5. 你觉得https是怎么做到安全传输的

   ```
   1. SSL为通信建立一个信息安全通道，来保证数据传输的安全
   2. SSL依靠证书来验证服务器的身份，确定网站的真实性。
   ```

6. 关于浏览器的缓存机制你有了解吗

     ```
     **强制缓存**：通过响应头**Expires**和**Cache-Control**控制
     
     **协商缓存**：通过响应头**Last-Modified / If-Modified-Since和Etag / If-None-Match**控制，协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。 1 . 协商缓存生效，返回304   2. 协商缓存失效，返回200和请求结果结果
     ```

7. 回流和重绘之间有什么区别

     简单理解： 回流==》布局       重绘=》布局好加上样式后的外观                所以回流一定重绘，重绘不一定回流

     当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘

8. 让一个矩形的高度等于屏幕宽度的一半, 该怎样

   确定是屏幕： window.screen 对象；

   如果是浏览器窗口：1. js获取计算得到   2. 新单位：50vw    3. padding/margin 百分比单位 是相对于父级元素的width，根据该条件设置height：0，padding：25% 0； 只要父级宽度是窗口宽度就行

9. css布局, 一行只容纳三个, 换行向左对齐, 怎么实现

   flex：父级：flex-wrap：wrap;flex-direction:row; align-content: flex-start; 子级：flex-basis：33%

10. 如何清除浮动的副作用

    1. clear：both  2. 父级：拥有高度， 2.overflow：hidden

       现在流行：在父级的伪类：after中清除浮动

11. flex布局如设置整盒子之间的间距, 都有什么区别

    ​	1. margin  2. just-content：space-between | space-around

12. var, let, const之间什么区别

    1. let（变量）,const（常量）: a块级作用域; b暂时性死区;c全局声明也不绑定在全局对象上;d不可重复声明

    2. var: a作用域为当前执行上下文;b变量提升;c全局声明就会绑定在全局对象上;d可重复声明

       理解：暂时性死区，其实let和var都存在提升，但是执行上下文创建阶段let变量没有初始化，var变量初始化为undefined了，以let变量只有在该声明行执行时才会初始化。

13. 如何实现一个const不可更改

    1. defineProperty==》writable：false
    2. 这里参照vue数据劫持方案：最开始通过defineProperty，后面通过proxy代理，来实现get，set，这里我们对set动手脚就可以让变量不被修改了，还可以在修改时抛出错误。

14. 箭头函数和普通函数的区别

    1. 书写上更加简单
    2. 与this相关的一切都没有：
       1. 没有自己的this（不能绑定this，只能使用其声明所在执行上下文的this）
       2. 由于没有自己的this，so也不能作为构造函数使用，不能使用super
       3. 不能做构造函数，原型也就没有意义，so没有prototype
       4. 箭头函数不能使用生成器 即 ‘*’ 和 ‘yield’
    3. 没有自己的arguments，使用arguments时，是用了声明处外层的arguments

15. 箭头函数和普通函数都是在何时确定this指向的

    1. 箭头函数是在声明时，从执行上下文上确定的，所以call，apply，bind无效
    2. 普通函数是在调用的时候，或者通过call，apply，bind绑定的时候

16. 几个扩展运算符的基本应用

    1. 解构赋值获取多余的值
    2. 合并数组
    3. 展开任意可迭代对象，拥有迭代器的对象
    4. 函数参数表中，放在最后，接收多余的参数（剩余参数）

17. 能简单介绍一下事件循环机制吗

    事件队列 + 事件循环 + 宏任务/微任务（Promise）

18. 一道简单的事件循环的题, 说执行顺序, 并解释

    现场发挥

19. 实现一个`sleep`函数

    * 阻塞式：通过循环，不停比较时间，阻塞代码继续运行

    * 异步式：核心是利用setTimeout，底层都是 ‘Promise’ 或者直接 ‘回调’

20. 数组循环的话map和forEach有什么区别

    * map是遍历并映射一个新的数组

    * forEach只有遍历的功能

21. 实现数组方法flat, 并可以通过传参控制扁平化多少层

    递归或者循环，内部通过扩展运算符来展开，层数通过变量控制

22. ~~说一下vue数据双向绑定原理~~

23. ~~$set是如何实现的, 具体用来解决什么问题~~

24. ~~能详细的说一下, vue是如何实现派发更新/收集依赖的吗~~



1. 说一下平时项目中遇到的一个难点亮点

   ​	印象最深刻的应该是，随着项目中内容越来越多，项目做到中期，发现打包速度越来越慢，当时任务进度卡的比较紧，一直没有时间做webpack打包优化。某次超过了10分钟后，之后一旦压缩js就打包失败，我申请了优化的工作，单独拉了一个分支优化配置。

   ​	打包失败的问题是通过提高node内存分配解决的；

   ​	慢的问题，一开始主要是对UglifyJsPlugin插件下手，开启多核，启用缓存等等都试了，时间少了一些，但是还是太长。最后决定尝试一下升级webpack4==》5，整个升级过程比较痛苦，其中除了比较大问题的是各种文件名的hash（contenthash，chunkhash，hash===弃用，转为==》fullhash）设置，导致一直报错，后来纠正后终于成功了。5自带的TerserPlugin默认配置，加上它的缓存机制，成功升级后非第一次的打包时间都压缩到了2分钟以内。后面又相继做了一些其它的优化，使用了happypack ， 对spliteChunk策略做了一些调整。

2. 两个页面跨域名如何读取`localStore`中的数据, 除了`postMessage`还有吗

   1. 通过url

3. 服务端语言平时了解过哪些, nodejs, php, java之类的

   nodejs

4. ~~vue里面从设置变量到页面更新, 中间主要的流程都有哪些~~

5. ~~能详细的说一下`Dep`订阅中心的机制吗~~

6. ~~vue是如何对比新旧节点, 然后实现页面更新的~~

7. ~~diff算法中除了key属性之外, 还有别的增加对比效率的东西吗~~

8. ~~如果说让你来提升一下diff算法的对比效率, 你有什么想法和思路吗~~

9. ~~vuex的数据的响应式是如何处理的, 那你有什么思路吗~~

10. ~~`vue-router`的`hash`和`history`有什么区别~~

11. ~~`router-view`是如何定位到将要发生改变并渲染的组件呢~~

12. 说一下js的基本数据类型和引用类型, 二者有什么区别

    1. 基本类型：1 变量直接存储值 2 修改时直接修改值本身 3. 比较时，比较的是值本身，且运算时会发生类型转换 4. 基本上来说（不是全部）基本类型存在其对应的包装类型 实现 基本类型 和 复杂类型 之间的 相互转换
    2. 引用类型：1 变量存储值的引用 2 修改变量时是在修改引用地址，值本身不变，可以通过引用“.”来修改值 3  比较时，比较的是引用地址，如果参与到运算，会隐式的通过 valueOf 和 toString 来进行变换

13. 拷贝js的数据结构有哪些方式, 如何实现一个深拷贝

    1. 通过他们自带的一些方法，比如数组的 slice，concant等
    2. 通过新语法，数组的与对象的 扩展运算符 ...  与解构运算

14. 对象和函数之间有什么具体的区别吗, 二者之间有什么关联

    1. 函数本身其实也是特殊的对象，但是他拥有prototype，我们可以通过它来实现继承，而对象不能
    2. 对象能封装数据，对象或者函数； 函数是特殊的对象（因为它继承于对象）除了对象的能力，它还能够直接封装代码并执行（函数或者构造函数），形成一个可以输入，操作，输出的封闭结构。

15. 能说一下js里面关于原型和原型链的概念吗

    1. 原型的出现是为了继承
    2. 普通函数上拥有prototype ， 而一般对象上有_proto_, 当一个对象的_proto_指向一个函数的prototype。这个时候我们可以把这个函数看作一个类型，这个对象就是该类型的实例对象
    3. 也就是谁通过new 实例化了该对象，
    4. 当访问一个对象的属性时，会先查看对象本身是否拥有该属性，如果没有，就会去该对象proto上去找（这里时实例化的类，也就是类型上的prototype），如果还没有，继续通过proto向上找(继承)，直到遇到原型链的顶端null为止
    5. 整个过程找到了，该属性就有值，没有找到，该属性的值就为undefined

16. 如何实现一个es5的原型链继承

    实现继承核心点：

    1. this指向
    2. 继承父级的内部属性（实例）
    3. 原型链构建

      实现第一第二点可以通过apply，call调用把this绑定到父亲的函数中执行来实现，术语叫做 ‘方法借用’

     实现第三点，需要给子函数与父函数的原型上搭一座桥：可以直接 子.protp =>父.prototype  也可以通过Object.create()来做，后面这个方式记得加上custructor引用关系

17. 如果是想继承父类的实例属性和实例方法该如何实现

    1. 参照上

18. es6的class在继承的时候为什么要调用super方法, 用来做什么的

    1. 参照上， 类似‘方法借用’ 

19. 介绍一下你的开源项目, 实现的思路, 你从中得到了哪些收获

    ​	无

20. 小程序和H5什么区别吗, 小程序的渲染原理和交互通信是如何做的 (渲染引擎, 交互引擎)

    不知道

21. ~~vue3平时有用到过吗, vue3主要的升级点和改动的地方能说一说吗~~

22. ~~vue3的compositionAPI的初衷是什么, 相较于vue2的optionsAPI有什么优点~~

23. babel是怎么通过webpack把一些浏览器不支持的语法进行转换的

    1. Parser 解析
       第一步主要是将 ES6 语法解析为 AST 抽象语法树。简单地说就是将代码打散成颗粒组装的对象。这一步主要是通过 babylon 插件来完成。
    2. Transformer 转换
       第二步是将打散的 AST 语法通过配置好的 plugins（babel-traverse 对 AST 进行遍历转译）和 presets （es2015 / es2016 / es2017 / env / stage-0 / stage-4 其中 es20xx 表示转换成该年份批准的标准，env 是最新标准，stage-0 和 stage-4 是实验版）转换成新的 AST 语法。这一步主要是由 babel-transform 插件完成。plugins 和 presets 通常在 .babelrc 文件中配置。
    3. Generator 生成
       第三步是将新的 AST 语法树对象再生成浏览器都可以识别的 ES5 语法。这一步主要是由 babel-generator 插件完成

24. 平时项目中用的什么css预处理器, 还是其他postcss之类的配置

    sass（通过css-moudle模块化）+ postcss（一般就用autoprefixer实现兼容性的前缀生成）

25. 如果让你实现一键换肤的功能, 你会如何实现, 除了css变量你还有其他方案吗

    1. 样式类的切换

26. 为什么css变量可以在运行时做更新呢, css变量他会带来什么问题吗

    1. 可以，可以通过js对对应的js变量的值进行修改

    2. 当使用 CSS 变量时，我们总是需要知道变量是在哪个作用域内定义的，如果改变它，是否会影响许多子元素，从而产生大量的样式重新计算。

       结合使用 `calc()` 和 CSS 变量是获得更大灵活性和限制我们需要定义的变量数量的好方法。在不同的浏览器中测试 `calc()` 与 CSS 变量的组合，没有显示任何大的性能问题。然而，一些浏览器对一些单位（如 `deg` 或 `ms`）的支持仍然有限，必须牢记这一点。

27. 你总结一下你做前端这几年年了, 有哪些擅长的点和欠缺的点

    欠缺的是，一直没有专门找时间去把算法以及设计模式弄一下
    擅长的可能是处理问题，这方面的能力在当老师那段时间得到了很大的提升，学生总能提出或者遇到或低级，或困难的问题。而不管什么问题，即便不能立马解决也要想办法去解决给学生一个交代，不然没办法立信。